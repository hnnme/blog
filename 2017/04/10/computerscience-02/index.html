<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="컴퓨터공학 - 2월23일"/>




  <meta name="keywords" content="컴퓨터공학," />





  <link rel="alternate" href="/blog/default" title="JiHyunLee | blog">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/apple-touch-icon-120x120.png?v=1.1" />



<link rel="canonical" href="https://hnnme.github.io/blog/2017/04/10/computerscience-02/"/>


<meta name="description" content="http://www.github.com:443/abc/ Port 가상의 논리적 통신 연결단 번호로 구분  항구번호를 통해서 여러갈래의 길이 있어서 다른 목적에 따라 사용 접합부분, 신호가 들어가는 부분을 포트라고 한다. 0~65535 0 ~ 1024  : well-known port - 가상의 통로  80번 포트 : HTTP 웹페이지 전송 12www.dau">
<meta name="keywords" content="컴퓨터공학">
<meta property="og:type" content="article">
<meta property="og:title" content="컴퓨터공학 - 2월23일">
<meta property="og:url" content="https://hnnme.github.io/blog/2017/04/10/computerscience-02/index.html">
<meta property="og:site_name" content="JiHyunLee | blog">
<meta property="og:description" content="http://www.github.com:443/abc/ Port 가상의 논리적 통신 연결단 번호로 구분  항구번호를 통해서 여러갈래의 길이 있어서 다른 목적에 따라 사용 접합부분, 신호가 들어가는 부분을 포트라고 한다. 0~65535 0 ~ 1024  : well-known port - 가상의 통로  80번 포트 : HTTP 웹페이지 전송 12www.dau">
<meta property="og:image" content="http://onlinecmag.com/wp-content/uploads/2015/01/osi-model.jpg?x59574">
<meta property="og:image" content="https://www.networkel.com/wp-content/uploads/2016/12/osimodel-1.jpg">
<meta property="og:image" content="http://www.ebrahma.com/wp-content/uploads/2013/09/OSI-Model.jpg">
<meta property="og:image" content="https://docs.trafficserver.apache.org/en/latest/_images/http_headers.jpg">
<meta property="og:image" content="http://niyuj.com/wp-content/uploads/2016/05/C2GNfi.png">
<meta property="og:updated_time" content="2017-04-10T16:42:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="컴퓨터공학 - 2월23일">
<meta name="twitter:description" content="http://www.github.com:443/abc/ Port 가상의 논리적 통신 연결단 번호로 구분  항구번호를 통해서 여러갈래의 길이 있어서 다른 목적에 따라 사용 접합부분, 신호가 들어가는 부분을 포트라고 한다. 0~65535 0 ~ 1024  : well-known port - 가상의 통로  80번 포트 : HTTP 웹페이지 전송 12www.dau">
<meta name="twitter:image" content="http://onlinecmag.com/wp-content/uploads/2015/01/osi-model.jpg?x59574">


<link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>


  <link rel="stylesheet" type="text/css" href="/blog/lib/fancybox/jquery.fancybox.css" />




<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: true
    },
  };
</script>




  



    <title> 컴퓨터공학 - 2월23일 - JiHyunLee | blog </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/blog/." class="logo">JiHyunLee | blog</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/blog/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/blog/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          컴퓨터공학 - 2월23일
        
      </h1>

      <time class="post-time">
          Apr 10 2017
      </time>
    </header>



    
            <div class="post-content">
            <p><a href="http://www.github.com:443/abc/" target="_blank" rel="external">http://www.github.com:443/abc/</a></p>
<h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h3><ul>
<li>가상의 논리적 통신 연결단</li>
<li>번호로 구분</li>
</ul>
<p>항구번호를 통해서 여러갈래의 길이 있어서 다른 목적에 따라 사용</p>
<p>접합부분, 신호가 들어가는 부분을 포트라고 한다.</p>
<p>0~65535</p>
<p>0 ~ 1024  : well-known port - 가상의 통로</p>
<p> 80번 포트 : HTTP 웹페이지 전송</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">www.daum.net:80</div><div class="line">www.daum.net호스트를 찾아서 80번 구멍으로 들어가는데</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">www.daum.net:800</div><div class="line">이 경우 잘못된 곳에 정착하는 경우 열리지 않는다.응답을 하지 않고 800포트는 열려있지않기떄문에</div></pre></td></tr></table></figure>
<p>443번 포트는 http통신을 위한 것</p>
<p>보안용은 안쓰나?</p>
<p><a href="http://www.naver.com:80" target="_blank" rel="external">http://www.naver.com:80</a> // 여기로는 들어가짐</p>
<p><a href="https://www.naver.com:80" target="_blank" rel="external">https://www.naver.com:80</a> // 여기로는 안들어가지는데 그것은 네이버에서 https서비스는 하지않다는것.</p>
<p>해킹시 포트를 타고 들어와서 해킹을 하기도 함</p>
<p>그래서 방화벽을 세우거나 함</p>
<p>예) 인천공항에 비행기가 출항하려고 떠다니는것 처럼</p>
<p>수강신청시 몇만명이 80포트로 들어가려고 하다보니 대기하다가 들어가고 그런것인데</p>
<p>미리 다른 포트를 열어놓고 수강신청을 쉽게 하는것</p>
<p>DNS</p>
<p>OSI 계층</p>
<p>​                            [ 7 layers of the OSI Model ]</p>
<p><img src="http://onlinecmag.com/wp-content/uploads/2015/01/osi-model.jpg?x59574" alt=""></p>
<p><img src="https://www.networkel.com/wp-content/uploads/2016/12/osimodel-1.jpg" alt=""></p>
<p>해당 경로를 통해서 데이터를 패킷에 묶여서 나옴</p>
<p>실제로 케이블들이 물리적으로 이어져있음 해저에 박혀있음</p>
<p>그래서 로밍서비스시 비싼 이유가 고속도로에 돈받는것처럼 그런거</p>
<p>사실 그냥 인터넷 더 빠르게 사용할수 있는데 통신사에서 대로폭 제한을 해서 돈낸만큼만 대로폭제한을 해서 그만큼만 사용하게 된다.</p>
<p>전기의 저항은 가다가 점점 줄어듬 열을 받고 해서 </p>
<p>1-10 을 주면 7 6 으로 줄어들게 되서 이게 처음에 10이였는지 9이였는지 모르기에</p>
<p>0 -1 으로 해서 1로 시작해서 0.6이 되도 1인줄알게 컴퓨터는 0과 1을 사용한다.</p>
<p>증폭기를 중간중간에 사용하는것도 그런것 약해지니까 중간중간에 증폭기를 세움</p>
<p>대부분 전선은 구리를 사용한다 금은 너무 비싸니까.</p>
<p><img src="http://www.ebrahma.com/wp-content/uploads/2013/09/OSI-Model.jpg" alt=""></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>월드 와이드 웹에서 정보를 주고 받을 수 있도록 고안한 프로토콜</li>
<li>Well-known port: 80</li>
</ul>
<h3 id="HTTP의-역사"><a href="#HTTP의-역사" class="headerlink" title="HTTP의 역사"></a>HTTP의 역사</h3><ul>
<li>HTTP/0.9 : 1991~</li>
<li>HTTP/1.0 : 1996</li>
<li>HTTP/1.1: 1997</li>
<li>HTTP/2 : 2015</li>
</ul>
<h3 id="HTTP-Request-Response"><a href="#HTTP-Request-Response" class="headerlink" title="HTTP Request / Response"></a>HTTP Request / Response</h3><ul>
<li>Request: 클라이언트에서 웹 서버로 요청</li>
<li>Response: 웹 서버에서 클라이언트로 응답</li>
</ul>
<p>www를 사용시 웹문서를 요청한다는 것</p>
<h3 id="HTTP-Header-Body"><a href="#HTTP-Header-Body" class="headerlink" title="HTTP Header / Body"></a>HTTP Header / Body</h3><ul>
<li>Header<ul>
<li>웹서버와 클라이언트사이에서 실질적인 데이터 외에 추가적인 정보를 교환할 수 있도록 선두에 삽입되는 정보</li>
</ul>
</li>
<li>Body<ul>
<li>웹 서버와 클라이언트 사이에서 전송할 실질적인 데이터</li>
</ul>
</li>
</ul>
<p>헤더가 없으면 컴퓨터는 어떤 데이터가 들어왔는지 알수 없다.</p>
<p><img src="https://docs.trafficserver.apache.org/en/latest/_images/http_headers.jpg" alt=""></p>
<p>사이트: <a href="https://docs.trafficserver.apache.org/en/latest/developer-guide/plugins/http-headers/index.en.html" target="_blank" rel="external">https://docs.trafficserver.apache.org/en/latest/developer-guide/plugins/http-headers/index.en.html</a></p>
<p>Content-length는 바디에 들어올 정보의 길이가 몇인지도 알려줌</p>
<p>Mime-type : text인지 xml, json인지가 들어가있음</p>
<h3 id="HTTP-Request-Methods"><a href="#HTTP-Request-Methods" class="headerlink" title="HTTP Request Methods"></a>HTTP Request Methods</h3><ul>
<li>웹 서버에 요구하는 작업의 종류에 따라 요청방법(Request Method)을 구분</li>
<li><strong>GET, POST, PUT, DELETE,</strong> HEAD, TRACE, OPTIONS, CONNECT, PATCH등</li>
</ul>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>요청 URL에 해당하는 자료의 전송을 요청</li>
<li>Request Body( X ) | 정보를 가져올시 body가 아닌 헤더에서 정보요청을 함 / 처음에는 바디는 필요없어도 된다.</li>
<li>Response Body( O )</li>
</ul>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><ul>
<li>서버가 처리할 자료를 전송</li>
<li>Request Body( O )  | 바디에 정보를 실어서 요청</li>
<li>Response Body ( O )</li>
</ul>
<p><strong>CRUD</strong> </p>
<p>create, read, update, delete</p>
<p>POST, GET, PUT, DELETE</p>
<p>1) 사용자 정보 만들고</p>
<p>2) 사용자 정보를 요청받아 읽고 정보조회</p>
<p>3) 사용자 정보를 수정하고</p>
<p>4) 사용자 정보를 삭제</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>C</strong>reate</td>
<td>POST</td>
</tr>
<tr>
<td><strong>R</strong>ead</td>
<td>GET</td>
</tr>
<tr>
<td><strong>U</strong>pdate</td>
<td>PUT</td>
</tr>
<tr>
<td><strong>D</strong>elete</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><ul>
<li>해당 URI의 자료를 삭제</li>
<li>Request Body( X )</li>
<li>Response Body( O )</li>
</ul>
<h3 id="HTTP-Request-Methods-1"><a href="#HTTP-Request-Methods-1" class="headerlink" title="HTTP Request Methods"></a>HTTP Request Methods</h3><table>
<thead>
<tr>
<th></th>
<th>Request Body</th>
<th>Request Body</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GET</strong></td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>X</td>
<td>O</td>
</tr>
</tbody>
</table>
<p>Status</p>
<p>서버의 상태를 말해줌</p>
<h3 id="HTTP-Response-Status-Code"><a href="#HTTP-Response-Status-Code" class="headerlink" title="HTTP Response Status Code"></a>HTTP Response Status Code</h3><ul>
<li>1xx : 정보교환 / 조건부 응답</li>
<li>2xx: 성공</li>
<li>3xx: 리다이렉션 </li>
<li>4xx: 요청 오류</li>
<li>5xx: 서버 오류</li>
</ul>
<p>예) 404에러 페이지 정보를 찾지 못했을때</p>
<p><a href="https://developers.naver.com/main/" target="_blank" rel="external">https://developers.naver.com/main/</a></p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul>
<li><p>서버에 필요한 정보를 클라이언트에 임시/영구적으로 저장하기 위해 저장</p>
</li>
<li><p>사용자에 대한 지속적인 상태감시 및 상태참조의 목적</p>
</li>
<li><p>여러 페이지를 옮겨 다닐 때에도 통용될 정보에 주로 이용</p>
<p>예) 사용자 이름, 아이디, 장바구니, 최근 본 상품 등등</p>
</li>
</ul>
<p><img src="http://niyuj.com/wp-content/uploads/2016/05/C2GNfi.png" alt="cookie"></p>
<p>구글은 사용자의 쿠키 번호를 갖고 쿠키에 검색을 뭘하는지 뭘하는지를 정보를 분석</p>
<h3 id="Cookie-in-JS"><a href="#Cookie-in-JS" class="headerlink" title="Cookie in JS"></a>Cookie in JS</h3><ul>
<li><p>Read Cookie</p>
<p>Var cookies = document.cookie</p>
</li>
<li><p>Write Cookie</p>
<ul>
<li>Document.cookie = “user_name=Jo; user_id=yagom”</li>
</ul>
</li>
</ul>
<h3 id="Cookie의-종류"><a href="#Cookie의-종류" class="headerlink" title="Cookie의 종류"></a>Cookie의 종류</h3><ul>
<li>영구적 쿠키 : 하드디스크에 저장<ul>
<li>디스크에 저장 - 만료일 후에 삭제</li>
<li>만료일을 집어늠</li>
</ul>
</li>
<li>세션 쿠키 : 메모리에만 저장: 요즘은 이거 씀<ul>
<li>주로 세션 정보를 보관하기 위해 사용</li>
<li>메모리에 저장 - 브라우저 종료후 사라짐</li>
</ul>
</li>
</ul>
<ul>
<li>악성코드 및 멀웨어에 의해 읽힐 수 있어 보안에 취약</li>
<li>보안에 신경쓸 필요가 없으며 간단한 데이터를 통신간에 유지하기 위해 사용</li>
</ul>
<p>참고: <a href="http://www.jynote.net/263" target="_blank" rel="external">http://www.jynote.net/263</a></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul>
<li>웹 서버가 HTTP 요청을 한 클라이언트를 식별하기 위해 사용</li>
<li>클라이언트의 최초 요청에 세션 쿠키로 <strong>임의의 난수를 생성</strong></li>
<li>클라이언트의 이후 요청에 세션ID를 <strong>헤더</strong>에 담아 보내면 서버에서는 이를 통해 클라이언트를 식별</li>
</ul>
<p>예) 아이피에 해당하는 세션키를 줬다가 다른곳에서 가서 인터넷을 했을시 아이피가 달라져서 세션이 만료됬다고 하는것과 같은것</p>
<p>쿠키는 서버에 부담이 덜 되고 </p>
<p>세션은 서버에 부담이 더 되고 계속 아이피에 해당하는 세션키를 주고 체크해야되지만 쿠키에 비해선 안전</p>
<p>세션쿠키가 세션에 사용되는것</p>
<p>세션 쿠키에 세션키만 갖고 있으면 되니까 쿠키보다 가볍고</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>임시저장소</p>
<ul>
<li>통상적 의미: 데이터나 값을 미리 복사해 놓은 임시 장소</li>
<li>웹 서버 - 클라이언트 모델에서의 캐싱<ul>
<li>서버-클라이언트 간 요청에 대한 응답을 저장해 두는 것</li>
<li>서버의 부하와 접속 속도 문제 완화</li>
<li>새로운 데이터의 갱신 문제</li>
</ul>
</li>
</ul>
<p>네이버에 자주들어가면 해당 사이트를 캐시에 저장해서 다음에 다시 들어가려고 했을때 요청의 응답이 없어도 캐시를 이용해서 보여지게 됨</p>
<p>캐시파일도 만료일을 알려주기도 함 그래서 갱신된게 있는지 서버에 요청해서 업데이트되기도 함</p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><ul>
<li>현재 많이 사용되고 있는 HTTP/1.1을 개선하기 위한 차기 버전</li>
<li>아직 많이 사용되지 ㅇ낳고 있지만 곧 확장될 예정</li>
</ul>
<h3 id="Why-HTTP-2"><a href="#Why-HTTP-2" class="headerlink" title="Why HTTP/2?"></a>Why HTTP/2?</h3><ul>
<li>헤더 압출 지원<ul>
<li>쿠키의 과다 사용. . </li>
<li>HTTP/1.1의 헤더는 너무 크고 복잡</li>
<li>속도 저하의 원인</li>
</ul>
</li>
<li>너무 빈번한 Round-trip<ul>
<li>한번의 요청으로 다양한 데이터 응답 가능</li>
</ul>
</li>
</ul>
<p>보통 한개의 페이지만 해도 스크립트,이미지 ,동영상파일을 받는데 왔다갔다를 많이 하게 되는데 </p>
<p>HTTP/2는 한번에 응답해주는것이 기본 컨셉</p>
<h3 id="패킷이란"><a href="#패킷이란" class="headerlink" title="패킷이란?"></a>패킷이란?</h3><p>네트워크를 통해서 전송되는 단위, 데이터의 묶음</p>
<h3 id="소켓통신"><a href="#소켓통신" class="headerlink" title="소켓통신"></a>소켓통신</h3><p>Http는 라운드트립이 되는 식인데 왔다갔다 뭘 부르고자 할때 한번 요청하고 응답을 받는 식인데</p>
<p>채팅에 경우 http는 계속 주고 받고를 해야 되므로 좀 그렇다</p>
<p>수로를 파서 주든지 받든지 가상의 통신의 설로를 만들고 </p>
<p>한쪽에서 양쪽에서 계속 실시간으로 싱크를 하고 있는 모습</p>
<p>비용이 많이 듬 계속 감시해야 되는 의무가 있어서 시스템자원들을 소모하게 됨</p>
<p>서버부하되는것도 생각하면 데이터베이스를 잘 짜지않으면 별로임 잘 사용할줄 모르면 별로임</p>
<p>풀링</p>
<h2 id="암호화"><a href="#암호화" class="headerlink" title="암호화"></a>암호화</h2><ul>
<li>해시</li>
<li>대칭키</li>
<li>공개키(비대칭키)</li>
</ul>
<h3 id="해시-함수"><a href="#해시-함수" class="headerlink" title="해시 함수"></a>해시 함수</h3><ul>
<li>임의의 데이터(암호 등)를 고정된 길이의 데이터로 매핑하여 원래의 입력값과의 관계를 찾기 어렵게 만든것</li>
<li>SHA, MD5 등</li>
</ul>
<p>해시함수로 암호화해서 저장</p>
<p>예) 로그인을 위해 유저가 정보를 적으면 아이디, 이름, 비밀번호 </p>
<p>비밀번호를 암호화 해서 데이터베이스에 저장</p>
<p>로그인할때 입력한 비밀번호를 암호화해서 데이터베이스에 있는 암호화된애랑 비교</p>
<p>이것은 0부터 z까지 쳐서 만들면 저 암호화된애들을 집어넣으면 저 암호화된 애들을 찾을수 있게 됨</p>
<h4 id="해커-와-크래커"><a href="#해커-와-크래커" class="headerlink" title="해커 와 크래커"></a>해커 와 크래커</h4><p>해커는 막으면서 공격하고</p>
<p>그래커는 구멍을 찾아서 공격하는거</p>
<h3 id="대칭키-암호화"><a href="#대칭키-암호화" class="headerlink" title="대칭키 암호화"></a>대칭키 암호화</h3><ul>
<li>암호와와 복호화에 같은 암호키를 쓰는 알고리즘</li>
<li>DES, AES, SEED등</li>
</ul>
<p>O &gt;&gt; *</p>
<ul>
<li>&lt;&lt; O</li>
</ul>
<p>암호화할 키를 알게 되면 끝이라는 단점이</p>
<h3 id="공개키-비대칭키-암호화"><a href="#공개키-비대칭키-암호화" class="headerlink" title="공개키(비대칭키) 암호화"></a>공개키(비대칭키) 암호화</h3><ul>
<li>공개키로 암호화된 데이터를 비밀키를 사용하여 복호화 할 수 있는 암호화 알고리즘</li>
<li>RSA등</li>
</ul>
<p>예) A와 B는 암호화할 키와 복호화할 키를 각각 가지고 있음</p>
<p>잠글떄 쓰는 키를 줘도 풀수는 없음</p>
<p>암호화 할때 쓰는 키</p>
<p>그러나 여는 키는 각자 혼자 갖고 있기떄문에 여는 키만 안털리면 됨</p>
<p>알고리즘이 복잡해서 푸는데 메모리를 많이 차지하게 되고 연산을 위해 cpu도 많이 쓰게 됨</p>
<p>그래서 사람들이 생각한 것이</p>
<p>처음에는 공개키 비대칭키를 사용하여 비밀키를 주고 받은후  나중에 주고 받을때는  대칭키를 사용하기로 함</p>
<p>http SSL같은거에 사용 이게 암호화 방식</p>
<p>공인 인증서가 유사한 컨셉이 그것임</p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/blog/tags/컴퓨터공학/">컴퓨터공학</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/blog/2017/04/10/about-anchor-tag/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">a 태그에 대해서</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/blog/2017/04/10/vuex/">
        <span class="next-text nav-default">vuex</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
    2017
    <span class="footer-author">Jihyun Lee.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    
  





  
    <script type="text/javascript" src="/blog/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/blog/lib/fancybox/jquery.fancybox.pack.js"></script>
  

    <script type="text/javascript" src="/blog/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/blog/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
